# PHP Коллекции
Библиотека для удобной работы с массивами данных различных структур с использованием функционального подхода. В основе лежат структуры данных, такие как: Список, Карта, Множество, Стек, Очередь. 

Для обхода и преобразования коллекций используется stream api (Stream), который обеспечивает функциональный подход.

Читать на других языках: [English](../README.md)

## Системные требования
[```PHP 7.1+```](https://www.php.net/downloads)

## Установка
Установить и использовать библиотеку в собственном проекте можно использовав  менеджер зависимостей [Composer](https://getcomposer.org/)
```bash
composer require worksolutions/php-collections
``` 

## Пример использования
```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

// Отобрать элементы по фильтру
CollectionFactory::from([1, 2, 3])
    ->stream()
    ->filter(Predicates::greaterThan(1))
    ->getCollection(); // Collection [2, 3]

// Распечатать все файлы в директории
CollectionFactory::fromIterable(new DirectoryIterator(__DIR__))
    ->stream()
    ->each(static function (SplFileInfo $fileInfo) {
        echo $fileInfo->getFilename() . "\n";
    });

```

## Основные концепции

В основе использования библиотеки лежит последовательный подход обработки и преобразования данных. Создание некого конвейера преобразования, где можно последовательно выполнять некие шаги. Каждый шаг отвечает только за свой небольшой кусочек работы. В этом случае шаги можно переиспользовать так как они являются атомарными.

Фундаментально библиотека состоит из нескольких частей, это: 

- [Структуры данных.](#Структуры-данных) Каждая имеет свою особенность, выраженную при помощи интерфейса и описания к нему, и реализацию. При этом реализации поведения структур данных могут быть разные.
- [Фабрика создания коллекции.](#Фабрика-создания-коллекции) Имеет множество статических методов для удобного создания коллекций.
- [Потоки обхода коллекций.](#Потоки-обхода-коллекций) Предназначен для обхода и преобразования коллекций, при этом каждое преобразование создает новый экземпляр коллекции.
- [Набор функций обхода и преобразования.](#Набор-функций-обхода-и-преобразования) Состоит из заранее подготовленных конструкторов функций для удобного использования в момент обхода. На их примере можно создать и использовать собственные функции более специфичные для вашей предметной области.

## Структуры данных

В основе библиотеки лежат самые популярные структуры данных которые являются самодостаточными для использования без каких-либо посторонних библиотек и классов. Все остальные части библиотеки основываются на эти структуры, в частности на интерфейс `Collection`. Все структуры данных коллекций содержат множество элементов с которыми можно проводить основные процедуры, такие как: обход, преобразование, агрегирования и т.д.

- [Коллекция (Collection)](#коллекция-collection)
- [Список (ListSequence)](#список-listsequence)
- [Множество (Set)](#множество-set)
- [Очередь (Queue)](#очередь-queue)
- [Стек (Stack)](#стек-stack)
- [Карта (Map)](#карта-map)

### Коллекция (Collection) 
[[↑ Структуры данных]](#Структуры-данных)

Основной базовый интерфейс коллекций. Все структуры данных кроме `карт (Map)` реализуют этот интерфейс, весь дополнительный функционал (Фабрики, Потоки обхода) используют данный интерфейс. Для поддержания универсальности в своих приложениях рекомендуется использовать именно интерфейс  `Collection`, но только в том случае если это не противоречит назначению использования структуры. 

Коллекции доступны для обхода при помощи цикла [```foreach```](#обход-коллекции-при-помощи-цикла-foreach).

#### Методы интерфейса

- [*add* – Добавление элемента в коллекцию](#add---добавление-элемента-в-коллекцию)
- [*addAll* – Добавление множества элементов в коллекцию](#addall---добавление-множества-элементов-в-коллекцию)
- [*merge* – Слияние коллекций](#merge---слияние-коллекций)
- [*clear* – Удаление всех элементов коллекции](#clear---удаление-всех-элементов-коллекции)
- [*remove* – Удаление элемента коллекции](#remove---удаление-элемента-коллекции)
- [*contains* – Проверка на существование элемента в коллекции](#contains---проверка-на-существование-элемента-в-коллекции)
- [*equals* – Сравнение двух коллекций на эквивалентность](#equals---сравнение-двух-коллекций-на-эквивалентность)
- [*size* – Получение количества элементов в коллекции](#size---получение-количества-элементов-в-коллекции)
- [*isEmpty* – Проверка коллекции на пустоту](#isempty---проверка-коллекции-на-пустоту)
- [*toArray* – Получение элементов коллекции в виде массива](#toArray---получение-элементов-коллекции-в-виде-массива)
- [*copy* – Получение копии коллекции](#copy---получение-копии-коллекции)
- [*stream* – Получение потока обхода коллекции (Stream)](#stream---получение-потока-обхода-коллекции-stream)
- [Обход коллекции при помощи цикла *foreach*](#обход-коллекции-при-помощи-цикла-foreach)

#### _add_ - Добавление элемента в коллекцию
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
add($element: mixed): bool;
```
Добавляет элемент в конец коллекции. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->add(10); // [1, 2] -> [1, 2, 10];

```

#### _addAll_ - Добавление множества элементов в коллекцию
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
addAll($elements: iterable): bool;
```
Добавляет множества элементов в конец коллекции. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->add([10, 11, 12]); // true
$collection->toArray(); // [1, 2] -> [1, 2, 10, 11, 12];

```

#### _merge_ - Слияние коллекций
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
merge($collection: Collection): bool;
```
Метод объединяет текущую коллекцию с переданной. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$mergingCollection = CollectionFactory::from([11, 12]); // [11, 12]
$collection->merge($mergingCollection); // true
$collection->toArray(); // [1, 2, 10, 11, 12];

```

#### _clear_ - Удаление всех элементов коллекции
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
clear(): void;
```
Метод удаляет все элементы коллекции.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->clear(); // null
$collection->toArray(); // [];

```

#### _remove_ - Удаление элемента коллекции
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
remove($element: mixed): bool;
```

Удаление конкретного элемента в коллекции. Метод возвращает признак удаления элемента. Если элемента не существовало, вернется `false`.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->remove(2); // true
$collection->remove(4); // false
$collection->toArray(); // [1, 3];

```

#### _contains_ - Проверка на существование элемента в коллекции
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
contains($element: mixed): bool;
```

Проверка наличия конкретного элемента в коллекции. Если элемента не существует, вернется `false`.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->contains(2); // true
$collection->contains(4); // false

```

#### _equals_ - Сравнение двух коллекций на эквивалентность
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
equals($collection: Collection): bool;
```

Метод проверяет, что переданная коллекция эквивалентна текущей, это означает что все элементы одной коллекции содержатся в другой коллекции и количество элементов равно. В случае неравенства коллекций, вернется `false`.

```php

use WS\Utils\Collections\HashSet;

$set1 = new HashSet([1, 2, 3]);
$set2 = new HashSet([3, 2, 1]);
$set3 = new HashSet([3, 2]);

$set1->equals($set2); // true
$set2->equals($set1); // true
$set1->equals($set3); // false

```

#### _size_ - Получение количества элементов в коллекции
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
size(): int;
```

Метод возвращает число элементов в коллекции. Если коллекция пустая - 0.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->size(); // 3

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->size(); // false

```

#### _isEmpty_ - Проверка коллекции на пустоту
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
isEmpty(): bool;
```
Метод возвращает признак пустой коллекции. Если в коллекции существуют элементы, вернется `false`.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->isEmpty(); // false

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->isEmpty(); // true

```

#### _toArray_ - Получение элементов коллекции в виде массива
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
toArray(): array;
```

Метод индексированный массив состоящий из элементов коллекции, порядок следования элементов зависит от внутреннего представления.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->toArray(); // [1, 2, 3]

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->toArray(); // []

```

#### _copy_ - Получение копии коллекции
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
copy(): Collection;
```
Метод возвращает точную копию коллекции. Коллекции - мутабельны. Это означает, что применение методов модификации изменяет коллекцию, для гарантии неизменности коллекции рекомендуется применять метод копирования.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$copyOfCollection = $collection->copy(); // Collection

$copyOfCollection === $collection; // false

```

#### _stream_ - Получение потока обхода коллекции (Stream)
[[↑ Коллекция (Collection)]](#коллекция-collection)
```
stream(): Stream;
```

Метод объект который реализует интерфейс обхода коллекции (Stream). Поток обхода коллекции является очень мощным инструментом и в большинстве случаев при разработке приходится иметь дело именно с ним. [Подробнее...](#Поток обхода коллекции)

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection
    ->stream()
    ->each(static function (int $el) {var_export($el);}); // 1 2 3

```

#### Обход коллекции при помощи цикла _foreach_
[[↑ Коллекция (Collection)]](#коллекция-collection)

Коллекции доступны для обхода при в цикле *foreach*. Порядок перебора коллекции зависит от внутренней реализации конкретного класса.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]

foreach($collection as $item) {
    var_export($item);
}

```

### Список (ListSequence) 
[[↑ Структуры данных]](#Структуры-данных)

Списком является структура данных в которой строго определен порядок элементов. Списки с одинаковым набором элементов и разной их последовательностью не равны. Интерфейс ListSequence расширяет интерфейс Collection. 

Интерфейс списка (ListSequence) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс списка (ListSequence) реализуют классы: ```ArrayList, ImmutableList```

#### Методы интерфейса

- [*get* – Получение элемента по порядковому индексу](#get---получение-элемента-по-порядковому-индексу)
- [*set* – Замена элемента списка](#set---замена-элемента-списка)
- [*indexOf* – Получение порядкового индекса элемента](#indexof---получение-порядкового-индекса-элемента)
- [*lastIndexOf* – Получение порядкового индекса последнего подходящего элемента](#lastindexof---получение-порядкового-индекса-последнего-подходящего-элемента)
- [*removeAt* – Удаление элемента по индексу](#removeat---удаление-элемента-по-индексу)

#### _get_ - Получение элемента по порядковому индексу
[[↑ Список (ListSequence)]](#список-listsequence)
```
get($index: int): mixed;
```
Метод возвращает элемент по индексу. Если по индексу элемента не существует, вернет null. Первый элемент списка имеет индекс 0.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2);

$list->get(0); // 1
$list->get(1); // 2
$list->get(2); // null

```

#### _set_ - Замена элемента списка
[[↑ Список (ListSequence)]](#список-listsequence)
```
set($element: mixed, $index: int): mixed;
```
Метод заменяет элемент по индексу. Возвращает значение элемента который был заменен текущим методом. Если происходит попытка заменить не существующий элемент, OutOfRangeException будет выброшен.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2);

$list->set(3, 0); // 1
$list->set(4, 1); // 2
$list->set(4, 2); // OutOfRangeException

```

#### _indexOf_ - Получение порядкового индекса элемента
[[↑ Список (ListSequence)]](#список-listsequence)
```
indexOf($element: mixed): ?int;
```
Метод возвращает первый индекс найденного элемента. В случае отсутствия значения в списке, вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->indexOf(1); // 0
$list->indexOf(2); // 1
$list->indexOf(4); // null

```

#### _lastIndexOf_ - Получение порядкового индекса последнего подходящего элемента
[[↑ Список (ListSequence)]](#список-listsequence)
```
lastIndexOf($element: mixed): ?int;
```
Метод возвращает последний индекс найденного элемента. В случае отсутствия значения в списке, вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->indexOf(1); // 2
$list->indexOf(2); // 1
$list->indexOf(3); // null

```

#### _removeAt_ - Удаление элемента по индексу
[[↑ Список (ListSequence)]](#список-listsequence)
```
removeAt(int $index): mixed;
```
Метод удаляет элемент по индексу, элементы находящиеся после удаленного индекса перемещаются ближе к началу на одну позицию. Возвращает значение удаленного элемента. В случае отсутствия элемента по индексу вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->removeAt(1); // 2
$list->toArray(); // [1, 1, 3]

```

### Множество (Set)

[[↑ Структуры данных]](#Структуры-данных)

Множество содержит только уникальные элементы, порядок следования элементов может быть любым. То есть добавление элемента методом `add` не гарантирует его последнее место среди остальных элементов при итерировании и в случае наличия элемента с таким же значением, последний не добавится в множество. 

Уникальность определяется значением, а для объектов либо уникальностью конкретного объекта, либо в случае если объект реализует интерфейс ``HashCodeAware`` уникальностью результата вызова метода ``getHashCode(): string;``.

Интерфейс множества (Set) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс множества (Set) реализуют классы: ```HashSet```


### Очередь (Queue)
[[↑ Структуры данных]](#Структуры-данных)

Такая структура данных как очередь удобна для последовательной обработки данных в порядке поступления. Она обладает удобными методами добавления и потребления элементов. Первый элемент, который попал в очередь - первым ее и покинет.

Интерфейс очереди (Queue) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс очереди (Queue) реализуют классы: ```ArrayQueue```

#### Методы интерфейса

- [*offer* – Вставка элемента в очередь](#offer---вставка-элемента-в-очередь)
- [*poll* – Получение элемента и удаление его из очереди](#poll---получение-элемента-и-удаление-его-из-очереди)
- [*peek* – Получение элемента без удаления его из очереди](#peek---получение-элемента-без-удаления-его-из-очереди)

#### _offer_ - Вставка элемента в очередь
[[↑ Очередь (Queue)]](#очередь-queue)
```
offer($element): bool;
```
Метод добавляет элемент в конец очереди. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограниченной очереди.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2);

$queue->offer(3); // [1, 2, 3]
$queue->peek(); // 3

```

#### _poll_ - Получение элемента и удаление его из очереди
[[↑ Очередь (Queue)]](#очередь-queue)
```
poll(): mixed;
```
Метод возвращает элемент и удаляет его из начала очереди. В случае отсутствия элементов в очереди будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2);

$queue->peek(); // 2
$queue->poll(); // [1]
$queue->peek(); // 1

```

#### _peek_ - Получение элемента без удаления его из очереди
[[↑ Очередь (Queue)]](#очередь-queue)
```
poll(): mixed;
```
Метод возвращает элемент. Очередь при этом не изменяется, элемент остается на своем месте. В случае отсутствия элементов в очереди будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2, 3);

$queue->peek(); // 2
$queue->size(); // 3

```

### Стек (Stack)
[[↑ Структуры данных]](#Структуры-данных)

Стек является структурой данных логика работы которой противоположна логике работы очереди. Первый элемент попавшей в стек будет первым и извлечен из него.

Интерфейс стека (Stack) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс стека (Stack) реализуют классы: ```ArrayStack```

#### Методы интерфейса

- [*push* – Добавление элемента](#push---добавление-элемента)
- [*pop* – Получение последнего добавленного элемента](#pop---получение-последнего-добавленного-элемента)
- [*peek* – Получение последнего добавленного элемента без модификации стека](#peek---получение-последнего-добавленного-элемента-без-модификации-стека)

#### _push_ - Добавление элемента
[[↑ Стек (Stack)]](#стек-stack)
```
push($element: mixed): bool;
```
Метод добавляет элемент на вершину стека. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограничений.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2);

$queue->push(3); // [1, 2, 3]
$queue->peek(); // 3

```

#### _pop_ - Получение последнего добавленного элемента
[[↑ Стек (Stack)]](#стек-stack)
```
pop(): mixed;
```
Метод возвращает элемент с вершины стека. На вершину стека остается элемент добавленный перед полученным. В случае отсутствия элементов в стеке будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2, 3); // [1, 2, 3]

$queue->pop(); // 3
$queue->pop(); // 2
$queue->push(4); // [1, 4]
$queue->pop(); // 4
$queue->peek(); // 1

```

#### _peek_ - Получение последнего добавленного элемента без модификации стека
[[↑ Стек (Stack)]](#стек-stack)
```
peek(): mixed;
```
Метод возвращает элемент который расположен на вершине стека. В случае отсутствия элементов в стеке будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2, 3); // [1, 2, 3]

$queue->pop(); // 3
$queue->peek(); // 3
$queue->peek(); // 3

$queue->pop(); // 2
$queue->pop(); // 1
$queue->peek(); // RuntimeException

```

### Карта (Map)
[[↑ Структуры данных]](#Структуры-данных)

Карта представляет отображение или иначе говоря словарь, где каждый элемент представляет пару "ключ-значение". Ключи карты уникальны по значению, если это объекты, то уникальность достигается либо уникальностью ссылки на объект, либо в случае если объект реализует интерфейс ``HashCodeAware`` уникальностью результата вызова метода ``getHashCode(): string;``.

Интерфейс карты (Map) расширяет интерфейсы: ```IteratorAggregate```

Интерфейс карты (Map) реализуют классы: ```HashMap```

#### Методы интерфейса

- [*put* – Добавление пары *ключ/значение*](#put---добавление-пары-ключзначение)
- [*get* – Получение значения пары по ключу](#get---получение-значения-пары-по-ключу)
- [*keys* – Получение коллекции ключей карты](#keys---получение-коллекции-ключей-карты)
- [*values* – Получение коллекции значений карты](#values---получение-коллекции-значений-карты)
- [*remove* – Удаление пары по ключу](#remove---удаление-пары-по-ключу)
- [*containsKey* – Признак наличия пары по ключу](#containskey---признак-наличия-пары-по-ключу)
- [*containsValue* – Признак наличия пары по значению](#containsvalue---признак-наличия-пары-по-значению)
- [*size* – Количество пар в карте](#size---количество-пар-в-карте)

#### _put_ - Добавление пары *ключ/значение*
[[↑ Карта (Map)]](#карта-map)
```
put($key: mixed, $value: mixed): bool;
```
Метод добавляет пару ключ/значение в объект структуры. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограничений. Как ключом так и значением могут быть данные скалярных типов, массивы и объекты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map as $k => $v) {
    var_dump($k); // one | two
    var_dump($v); // 1   | 2
}

```

#### _get_ - Получение значения пары по ключу
[[↑ Карта (Map)]](#карта-map)
```
get($key): mixed;
```
Метод возвращает значение пары по ключу ``key``. В случае, если значения нет вернется ``null``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->get('one'); // 1
$map->get('three'); // null

```

#### _keys_ - Получение коллекции ключей карты
[[↑ Карта (Map)]](#карта-map)
```
keys(): Collection<mixed>;
```
Метод возвращает коллекцию состоящую из всех ключей карты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map->keys() as $k) {
    var_dump($k); // one | two
}

```

#### _values_ - Получение коллекции значений карты
[[↑ Карта (Map)]](#карта-map)
```
values(): Collection<mixed>;
```
Метод возвращает коллекцию состоящую из всех значений пар карты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map->keys() as $v) {
    var_dump($v); // 1 | 2
}

```

#### _remove_ - Удаление пары по ключу
[[↑ Карта (Map)]](#карта-map)
```
remove($key: mixed): bool;
```
Метод удаляет пару из карты по ключу ``key``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->remove('one');
foreach ($map->keys() as $v) {
    var_dump($v); // 2
}

```

#### _containsKey_ - Признак наличия пары по ключу
[[↑ Карта (Map)]](#карта-map)
```
containsKey($key: mixed): bool;
```
Метод возвращает признак наличия пары с ключом ``key``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->containsKey('one'); // true

```

#### _containsValue_ - Признак наличия пары по значению
[[↑ Карта (Map)]](#карта-map)
```
containsValue($value: mixed): bool;
```
Метод возвращает признак наличия пары со значением ``value``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->containsValue(1); // true
$map->containsValue(3); // false

```

#### _size_ - Количество пар в карте
[[↑ Карта (Map)]](#карта-map)
```
size(): int;
```
Метод возвращает количество пар.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->size(); // 2

$emptyMap = new HashMap();
$map->size(); // 0

```

## Фабрика создания коллекции
[[↑ В начало]](#PHP-Коллекции)

Фабрика ```CollectionFactory``` позволяет создавать объекты коллекций без использования конструктора конкретной реализации, а так же обладает другими удобными методами создания объектов коллекций. На данный момент, основной структурой библиотеки является ```ArrayList```, который и порождается фабрикой в статических методах.

### Пример использования фабрики

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::numbers(10)
    ->stream()
    ->each(Consumers::dump()); // dumps int(0), int(1), ...

```
#### Методы фабрики создания коллекции
- [*from* – Генерирование коллекции из массива элементов](#from---генерирование-коллекции-из-массива-элементов)
- [*fromIterable* – Генерирование коллекции при помощи любой итерируемой величины](#fromIterable---генерирование-коллекции-при-помощи-любой-итерируемой-величины)
- [*numbers* – Генерирование коллекции состоящей из элементов последовательности целых чисел](#numbers---генерирование-коллекции-состоящей-из-элементов-последовательности-целых-чисел)
- [*generate* – Генерирование коллекции при помощи генератора](#generate---генерирование-коллекции-при-помощи-генератора)

#### _from_ - Генерирование коллекции из массива элементов
[[↑ Фабрика создания коллекции]](#Фабрика-создания-коллекции)
```
from($values: array): Collection
```
Метод создает коллекцию элементы которой состоят из элементов переданного массива. 

На данный момент реализацией коллекции является ``ArrayList``, в будущем конкретная реализация может поменяться, при вызове данного метода стоит опираться только на интерфейс ```Collection```.
```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::from([1 ,2, 3])
    ->stream()
    ->each(Consumers::dump()); // dumps int(1), int(2), int(3)

```

#### _fromIterable_ - Генерирование коллекции при помощи любой итерируемой величины
[[↑ Фабрика создания коллекции]](#Фабрика-создания-коллекции)
```
fromIterable($iterable: iterable): Collection
```
Метод создает коллекцию элементы которой состоят из элементов переданного итератора. 

На данный момент реализацией коллекции является ``ArrayList``, в будущем конкретная реализация может поменяться, при вызове данного метода стоит опираться только на интерфейс ```Collection```.
```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;
use WS\Utils\Collections\Functions\Converters;

CollectionFactory::fromIterable(new DirectoryIterator(__DIR__))
    ->stream()
    ->map(Converters::toPropertyValue('filename'))
    ->each(Consumers::dump()); // Dumps strings with filenames
```

#### _numbers_ - Генерирование коллекции состоящей из элементов последовательности целых чисел
[[↑ Фабрика создания коллекции]](#Фабрика-создания-коллекции)
```
numbers($from: int, $to: ?int): Collection
```
Метод создает коллекцию, элементы которой состоят из последовательности целых чисел ```[$from .. $to]```. Если параметр ```$to``` не передан, вернется коллекция ```[0 .. $from]```.

На данный момент реализацией коллекции является ``ArrayList``, в будущем конкретная реализация может поменяться, при вызове данного метода стоит опираться только на интерфейс ```Collection```.
```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::numbers(10, 15)
    ->stream()
    ->each(Consumers::dump()); // Dumps  [10, 11, 12, 13, 14, 15]
```

#### _generate_ - Генерирование коллекции при помощи генератора
[[↑ Фабрика создания коллекции]](#Фабрика-создания-коллекции)
```
generate($times: int, $generator: ?callable): Collection
```
Метод создает коллекцию размерности ```$times```, элементы которой состоят из значений результатов вызова генератора ```$generator```.

На данный момент реализацией коллекции является ``ArrayList``, в будущем конкретная реализация может поменяться, при вызове данного метода стоит опираться только на интерфейс ```Collection```. Если нужно конкретный тип экземпляра коллекций - нужно использовать конструкторы реализаций или их статические методы.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::generate(3, static function () {
        return random_int(0, 10);
    })
    ->stream()
    ->each(Consumers::dump()); // Dumps for example [9, 7, 2]
```

## Потоки обхода коллекций
[[↑ В начало]](#PHP-Коллекции)

Для более удобного обхода и преобразования коллекций необходимо использовать потоки обхода коллекций (Stream). В основном все вычисления должны производится через stream. Для получения потока нужно вызвать метод коллекции ``Collection::stream()``. 

Обработка коллекции при помощи stream происходит через выполнения функций, интерфейсы которых должны соответствовать назначению обхода/преобразования. Всего их шесть:
- *Предикат (Predicate)*. Используется для фильтра элементов ``filter``, элемент остается в коллекции потока (stream) в случае если предикат вызванный для данного элемента вернет булевое положительное значение. Библиотека уже содержит некоторые [подготовленные предикаты](#predicates-предикаты).
- *Конвертер (Converter)*. Функции этого типа используются для преобразования коллекции потока ``map``. Конвертер должен вернуть значение которое по некоторому признаку соответствует переданному элементу коллекции. Библиотека уже содержит некоторые [подготовленные конвертеры](#converters-преобразователи-элементов).
- *Потребитель (Consumer)*. Функции потребителей не изменяют коллекцию потока, а используются для ее обхода  ``each``. Переданная функция будет вызвана для каждого элемента коллекции, результат выполнения функции не учитывается. Библиотека уже содержит некоторые [подготовленные потребители](#consumers-потребители).
- *Функции сравнения (Comparator)*. Компораторы участвуют в сортировке элементов для определения порядка сортировки двух значений. Должна возвращать целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй. [php.net usort](https://www.php.net/manual/en/function.usort.php). Библиотека уже содержит некоторые [подготовленные функции сравнения](#comparators-функции-сравнения).
- *Преобразователь (Reorganizer)*. Функции преобразователей преобразуют одну коллекцию в другую  ``reorganize`` не изменяя при этом объекта потока. Преобразования необходимы когда нужно получить итоговую коллекцию не просто преобразовывая один элемент в другой, а сформировать новую коллекцию основываясь на всей информации исходной коллекции. Примером могут служить методы перемешивания ```shuffle``` элементов или формирования порций ``chunk``. Библиотека уже содержит некоторые [подготовленные преобразователи](#reorganizers-преобразователи-потоков).
- *Функции сбора данных (Collector)*. Функции сбора данных применяются к потоку при помощи метода ``collect``, по сути результат выполнения функций этой группы и будет являться результатом выполнения потока. Метод  ```collect``` является терминальным, то есть вызовом этого метода поток обрывается.

Все потоки принадлежат интерфейсу ```Stream```, это означает что описание интерфейса гарантирует его корректное исполнение вне зависимости от конкретной реализации, исключения лишь составляют частные случаи поведения потоков (```when```).

Stream`s гарантируют, что после каждого метода модификации метод ``getCollection`` будет возвращать разные экземпляры объектов, что является надежным способом с точки зрения безопасности для поддержания иммутабельности при преобразовании.

#### Методы интерфейса потока

- [*each* – Обход элементов коллекции](#each---обход-элементов-коллекции)
- [*walk* – Ограниченный обход элементов коллекции](#walk---ограниченный-обход-элементов-коллекции)
- [*filter* – Фильтрация элементов коллекции](#filter---фильтрация-элементов-коллекции)
- [*map* – Отражение элементов коллекции потока](#map---отражение-элементов-коллекции-потока)
- [*reorganize* – Преобразование коллекции потока](#reorganize---преобразование-коллекции-потока)
- [*collect* – Сбор данных коллекции](#collect---сбор-данных-коллекции)
- [*sort* – Сортировка элементов коллекции](#sort---сортировка-элементов-коллекции)
- [*sortBy* – Сортировка элементов коллекции по значению](#sortby---сортировка-элементов-коллекции-по-значению)
- [*sortDesc* – Сортировка элементов коллекции в обратном порядке](#sortdesc---сортировка-элементов-коллекции-в-обратном-порядке)
- [*sortByDesc* – Сортировка элементов коллекции по значению в обратном порядке](#sortby---сортировка-элементов-коллекции-по-значению)
- [*reduce* – Сокращение коллекции в единое значение](#reduce---сокращение-коллекции-в-единое-значение)
- [*when* – Ограничение модификации потока по условию](#when---ограничение-модификации-потока-по-условию)
- [*always* – Отмена ограничений модификации потока](#always---отмена-ограничений-модификации-потока)
- [*getCollection* – Получение коллекции потока](#getcollection---получение-коллекции-потока)
- [*allMatch* – Полное совпадение всех элементов по предикату](#allmatch---полное-совпадение-всех-элементов-по-предикату)
- [*anyMatch* – Частичное совпадение всех элементов по предикату](#anymatch---частичное-совпадение-всех-элементов-по-предикату)
- [*findAny* – Получение произвольного элемента коллекции](#findany---получение-произвольного-элемента-коллекции)
- [*findFirst* – Получение первого элемента коллекции](#findfirst---получение-первого-элемента-коллекции)
- [*findLast* – Получение последнего элемента коллекции](#findlast---получение-последнего-элемента-коллекции)
- [*min* – Получение минимального элемента коллекции](#min---получение-минимального-элемента-коллекции)
- [*max* – Получение максимального элемента коллекции](#max---получение-максимального-элемента-коллекции)
- [*reverse* – Расположить элементы коллекции в обратном порядке](#reverse---расположить-элементы-коллекции-в-обратном-порядке)
- [*limit* – Сократить коллекцию до указанного размера](#limit---сократить-коллекцию-до-указанного-размера)

#### _each_ - Обход элементов коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
each($consumer: <fn($element: mixed, $index: int): void>): Stream;
```
Метод применяет к каждому элементу коллекции потока, функцию $consumer. Результат выполнения функции не учитывается. Вызов метода ```each``` не изменяет коллекцию потока, но в то же время получает доступ к каждому элементу в коллекции.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::numbers(10)
    ->stream()
    ->each(Consumers::dump()) // dumps each element
    ->each(static function ($el) { // prints strings 0, 1, 2, 3
        echo $el."\n"; 
    })
;

```

#### _walk_ - Ограниченный обход элементов коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
walk($consumer: <fn($element: mixed, $index: int): false|void>, $limit: ?int): Stream;
```
Метод применяет к каждому элементу коллекции потока, функцию ``$consumer``, так же как и в методе ``each``. Результат выполнения функции не учитывается. Вызов метода ```each``` не изменяет коллекцию потока, но в то же время получает доступ к каждому элементу в коллекции.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::numbers(10)
    ->stream()
    ->walk(Consumers::dump(), 5) // dumps only first 5 elements: 0, 1, 2, 3, 4
    ->walk(static function ($el) { // prints strings 0, 1, 2, 3. Method will be called only 5 times
        if ($el === 4) {
            return false;
        }
        echo $el."\n";
    })
;

```

#### _filter_ - Фильтрация элементов коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
filter($predicate: <fn($element: mixed): bool>): Stream;
```
Метод применяет к каждому элементу коллекции потока, функцию ``$predicate``. В случае если вызов предиката с элементов вернет отрицательный результат - ```false, 0, '', []```, элемент исключается из коллекции.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    ->filter(static function (int $el): bool {
        return $el % 2 === 0;
    })
    ->getCollection() // returns only first 5 elements: 0, 2, 4, 6, 8
;

```

#### _map_ - Отражение элементов коллекции потока
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
map($converter: <fn($element: mixed): mixed>): Stream;
```
Метод применяет к каждому элементу коллекции потока, подменяет переданные элементы коллекции на результаты выполнения функции.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    ->map(static function (int $el): int {
        return $el * 10;
    })
    ->getCollection() // returns 0, 10, 20, 30, 40, 50, 60, 70, 80, 90
;

```

#### _reorganize_ - Преобразование коллекции потока
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
reorganize($reorganizer: <fn($collection: Collection): Collection>): Stream;
```
Метод применяет ``$reorganizer`` к внутренней коллекции, затем заменяет внутреннюю коллекцию на результат вызова метода. Необходим когда следует выполнить преобразования основываясь на данных полной коллекции.

```php

use WS\Utils\Collections\ArrayStack;
use WS\Utils\Collections\Collection;
use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    // reverse collection 
    ->reorganize(static function (Collection $collection): Collection {
        $stack = new ArrayStack();
        foreach ($collection as $item) {
            $stack->push($item);
        }
        $reversed = CollectionFactory::empty();
        while (!$stack->isEmpty()) {
            $reversed->add($stack->pop());
        }
        return $reversed;
    })
    ->getCollection()
;

```

#### _collect_ - Сбор данных коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
collect($collector: <fn ($collection: Collection): mixed>): mixed;
```
Метод применяет ``$collector`` к внутренней коллекции и возвращает результат. Необходим, когда необходимо выполнить финальное действие над коллекцией с использованием потока. Терминальный метод.

```php

use WS\Utils\Collections\Collection;
use WS\Utils\Collections\CollectionFactory;

$sumOfElements = CollectionFactory::numbers(10)
    ->stream()
    // get sum of collection elements
    ->collect(static function (Collection $collection): int {
        $res = 0;
        foreach ($collection as $item) {
            $res += $item;
        }
        return $res;
    })
;

```

#### _sort_ - Сортировка элементов коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
sort($comparator: <fn($a: mixed, $b: mixed): int>): Stream;
```
Метод сортирует элементы согласно работе ``$comparator`` (компаратора). Компоратор определяет порядок сортировки двух значений. Должен возвращать целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй. [php.net usort](https://www.php.net/manual/en/function.usort.php)

```php

use WS\Utils\Collections\CollectionFactory;

$sortedCollection = CollectionFactory::generate(10, static function (): int {
        return random_int(0, 100);
    })
    ->stream()
    // get sorted collection
    ->sort(static function (int $a, int $b): int {
        return $a <=> $b;
    })
    ->getCollection()
;

```

#### _sortDesc_ - Сортировка элементов коллекции в обратном порядке
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
sort($comparator: <fn($a: mixed, $b: mixed): int>): Stream;
```
Метод сортирует элементы согласно работе ``$comparator`` (компаратора), но в отличии от обычной функции сортировки элемнты будут выстроены по убыванию. Компоратор определяет порядок сортировки двух значений. Должен возвращать целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй. [php.net usort](https://www.php.net/manual/en/function.usort.php)

```php

use WS\Utils\Collections\CollectionFactory;

$sortedDescendentCollection = CollectionFactory::generate(10, static function (): int {
        return random_int(0, 100);
    })
    ->stream()
    // get sorted collection in the reverse order
    ->sortDesc(static function (int $a, int $b): int {
        return $a <=> $b;
    })
    ->getCollection()
;

```

#### _sortBy_ - Сортировка элементов коллекции по значению
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
sortBy($extractor: <fn($el: mixed): scalar>): Stream;
```
Метод сортирует элементы согласно полученному значению функции ``$extractor`` для каждого элемента. Функция должна вернуть скалярное значение для возможности независимой оптимизированной сортировки. Аналогично работает метод сортировки по значению в обратном порядке ``sortByDesc``.

```php

use WS\Utils\Collections\CollectionFactory;

class Container {
    private $value;

    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$sortedCollection = CollectionFactory::generate(10, static function (): Container {
        return new Container(random_int(0, 100));
    })
    ->stream()
    // get sorted collection
    ->sortBy(static function (Container $container): int {
        return $container->getValue();
    })
    ->getCollection()
;

```

#### _reduce_ - Сокращение коллекции в единое значение
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
reduce($accumulator: <fn($el: mixed, $carry: mixed): mixed>): mixed;
```
Метод приводит коллекцию к единому значению. Функции передаются значения ``$el`` итерируемого элемента и результат вызова этой же функции на предыдущем элементе ``$carry``. В первой итерации ``$carry === null``. Терминальный метод. 

```php

use WS\Utils\Collections\CollectionFactory;

$sumOfCollection = CollectionFactory::numbers(10)
    ->stream()
    // get sum of collection elements
    ->reduce(static function (int $el, ?int $carry = null): int {
        return $carry + $el;
    })
;

```

#### _when_ - Ограничение модификации потока по условию
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
when($condition: bool): Stream;
```
Метод ограничивает модификацию при невыполнении условия ``$condition`` и все методы модификации и обхода не будут вызываться. Обратный метод - [``always``](#отмена-ограничений-модификации-потока). 

Блокируемые методы: 

 - each
 - walk
 - filter
 - reorganize
 - map
 - sort
 - sortBy
 - sortDesc
 - sortDescBy
 - reverse
 - limit

```php

use WS\Utils\Collections\Collection;
use WS\Utils\Collections\CollectionFactory;

$randomElementSizeCollection = CollectionFactory::numbers(random_int(0, 20));

$onlyTenElements = $randomElementSizeCollection
    ->stream()
    // get collection elements only 10 items
    ->when($randomElementSizeCollection->size() > 10)
    ->limit(10)
    ->when($randomElementSizeCollection->size() < 10)
    ->reorganize(static function (Collection $collection) {
        for ($i = $collection->size(); $i < 10; $i++ ) {
            $collection->add($i);
        }
        return $collection;
    })
;

```

#### _always_ - Отмена ограничений модификации потока
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
always(): Stream;
```
В случае если поток был заблокирован ранее для модификаций через условие [``when``](#ограничение-модификации-потока-по-условию), метод ``always`` отменяет ограничения на дальнейший вызов модифицирующих методов.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::numbers(20);

$onlyTenElements = $collection
    ->stream()
    // get collection elements only 10 items
    ->when($collection->size() > 5)
    ->limit(5)
    ->always()
    ->map(static function (int $el): int {
        return $el * 10;
    })
    ->getCollection() // [0, 10, 20, 30, 40]
;

```

#### _getCollection_ - Получение коллекции потока
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
getCollection(): Collection;
```
Метод возвращает коллекцию с учетом ранее выполненных преобразований. Даже если в потоке будут еще вызваны методы преобразования, полученная коллекция останется не измененной. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

$stream = CollectionFactory::numbers(10)
    ->stream();

$collection1 = $stream
    ->map(static function (int $el): int{
        return $el * 10;
    })
    ->getCollection()
;

$collection2 = $stream
    ->filter(static function (int $el): bool {
        return $el > 50;
    })
    ->getCollection()
;

$collection1->size() === $collection2->size(); // false

$collection2->toArray(); // [60, 70, 80, 90]

```

#### _allMatch_ - Полное совпадение всех элементов по предикату
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
allMatch($predicate: <fn($el: mixed): bool>): bool;
```
Метод вернет ``true``, если все вызовы ``$predicate`` над элементами коллекции будут истинными (``true``). Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    ->allMatch(static function (int $el): bool {
        return $el >= 1;
    }) // false, 0 is less than 1
;

```

#### _anyMatch_ - Частичное совпадение всех элементов по предикату
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
anyMatch(callable $predicate): bool;
```
Метод вернет ``true``, если хотя бы один вызов ``$predicate`` над элементами коллекции будет  истинным (``true``). Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    ->anyMatch(static function (int $el): bool {
        return $el > 0;
    }) // true, [1, 2, 3, 4, 5, 6, 7, 8, 9] are grate than 0
;

```

#### _findAny_ - Получение произвольного элемента коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
findAny(): mixed;
```

Метод вернет произвольный элемент коллекции, либо ``null``, если коллекция пустая. Не гарантирует того что элемент выбирается в случайном порядке. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10)
    ->stream()
    ->findAny() // for example - 5
;

```

#### _findFirst_ - Получение первого элемента коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
findFirst(): mixed;
```

Метод вернет первый элемент коллекции , либо ``null``, если коллекция пустая. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->findFirst() // 0
;

```

#### _findLast_ - Получение последнего элемента коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
findLast(): mixed;
```

Метод вернет последний элемент коллекции , либо ``null``, если коллекция пустая. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->findLast() // 9
;

```

#### _min_ - Получение минимального элемента коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
min($comparator: <fn($a: mixed, $b: mixed): int>): mixed;
```

Метод вернет наименьший элемент коллекции согласно сравнению функции компоратора, либо ``null``, если коллекция пустая. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->reorganize(Reorganizers::shuffle())
    ->min(static function (int $a, int $b): int {
        return $a <=> $b;
    }) // 0
;

```

#### _max_ - Получение максимального элемента коллекции
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
max($comparator: <fn($a: mixed, $b: mixed): int>): mixed;
```

Метод вернет наибольший элемент коллекции согласно сравнению функции компоратора, либо ``null``, если коллекция пустая. Терминальный метод.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->reorganize(Reorganizers::shuffle())
    ->max(static function (int $a, int $b): int {
        return $a <=> $b;
    }) // 9
;

```

#### _reverse_ - Расположить элементы коллекции в обратном порядке
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
reverse(): Stream;
```

Метод преобразует порядок элементов в обратную последовательность.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->reverse()
    ->getCollection() // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
;

```

#### _limit_ - Сократить коллекцию до указанного размера
[[↑ Потоки обхода коллекций]](#потоки-обхода-коллекций)
```
limit(int $size): Stream;
```

Метод сокращает количество элементов до указанного размера. В случае, если количество элементов уже меньше чем указано в ограничении ``$size``, количество элементов останется прежним.

```php

use WS\Utils\Collections\CollectionFactory;

CollectionFactory::numbers(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    ->stream()
    ->reverse()
    ->getCollection() // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
;

```

## Набор функций обхода и преобразования
[[↑ В начало]](#PHP-Коллекции)

Библиотека содержит конструкторы наиболее популярных функций, которые инициируют функции для из работы через потоки обхода и преобразования с заранее подготовленными параметрами.
Например: 
```php

use \WS\Utils\Collections\Functions\Predicates;

$equal10Predicate = Predicates::equal(10);

$equal10Predicate(11); // false
$equal10Predicate(10); // true

```
Вызов конструктор функции ```Predicates::equal(10)``` вернет функцию сравнения входного параметра со значением 10. 

Функции применяемые в библиотеке разделены на следующие типы:

- [*Predicates* – Предикаты](#predicates-предикаты)
- [*Comparators* - Функции сравнения](#comparators-функции-сравнения)
- [*Converters* - Преобразователи элементов](#converters-преобразователи-элементов)
- [*Reorganizers* - Преобразователи потоков](#reorganizers-преобразователи-потоков)
- [*Consumers* - Потребители](#consumers-потребители)

Каждый тип функции должен иметь соответствующий интерфейс для использования в определенных методах потоков. 

### Predicates Предикаты
[[↑ Набор функций обхода и преобразования]](#набор-функций-обхода-и-преобразования)

Группа конструкторов функций которые используются для фильтрации коллекции потока. Все методы возвращают проинициализированные функции с интерфейсом: ```<Fn($el: mixed): bool>```. Предикаты также позволяют работать со свойствами объектов. К примеру под свойством объекта `myPropety` подразумевается наличие публичного свойства в объекте с названием `myProperty` либо наличие методе `геттера` - `getMyProperty`.
- [*lock* – Блокировка](#lock---блокировка)
- [*notResistance* – Пропуск всех значений](#notresistance---пропуск-всех-значений)
- [*notNull* – Проверка значений на пустоту](#notnull---проверка-значений-на-пустоту)
- [*eachEven* – Пропуск элементов чётных вызовов](#eacheven---пропуск-элементов-чётных-вызовов)
- [*nth* – Пропуск элементов кратных вызовов](#nth---пропуск-элементов-кратных-вызовов)
- [*equal* – Проверка на эквивалентность](#equal---проверка-на-эквивалентность)
- [*lockDuplicated* – Блокировка значений дубликатов](#lockduplicated---блокировка-значений-дубликатов)
- [*lessThan* – Проверка значения на условие "меньше"](#lessthan---проверка-значения-на-условие-меньше)
- [*lessOrEqual* – Проверка значения на условие "меньше либо равно"](#lessorequal---проверка-значения-на-условие-меньше-либо-равно)
- [*greaterThan* – Проверка значения на условие "больше"](#greaterthan---проверка-значения-на-условие-больше)
- [*greaterOrEqual* – Проверка значения на условие "больше либо равно"](#greaterorequal---проверка-значения-на-условие-больше-либо-равно)
- [*not* – Проверка значения на неравенство](#not---проверка-значения-на-неравенство)
- [*in* – Проверка значения на нахождение во множестве](#in---проверка-значения-на-нахождение-во-множестве)
- [*notIn* – Проверка значения на отсутствие во множестве](#notin---проверка-значения-на-отсутствие-во-множестве)
- [*where* – Проверка свойства объекта на эквивалентность](#where---проверка-свойства-объекта-на-эквивалентность)
- [*whereNot* – Проверка свойства объекта на неравенство](#wherenot---проверка-свойства-объекта-на-неравенство)
- [*whereIn* – Проверка свойства объекта на нахождение во множестве](#wherein---проверка-свойства-объекта-на-нахождение-во-множестве)
- [*whereNotIn* – Проверка свойства объекта на отсутствие во множестве](#wherenotin---проверка-свойства-объекта-на-отсутствие-во-множестве)
- [*whereGreaterThan* – Проверка свойства объекта на условие "больше"](#wheregreaterthan---проверка-свойства-объекта-на-условие-больше)
- [*whereLessThan* – Проверка свойства объекта на условие "меньше"](#wherelessthan---проверка-свойства-объекта-на-условие-меньше)
- [*whereGreaterOrEqual* – Проверка свойства объекта на условие "больше либо равно"](#wheregreaterorequal---проверка-свойства-объекта-на-условие-больше-либо-равно)
- [*whereLessOrEqual* – Проверка свойства объекта на условие "меньше либо равно"](#wherelessorequal---проверка-свойства-объекта-на-условие-меньше-либо-равно)

#### _lock_ - Блокировка
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
lock(): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая на любой набор входных данных - будет возвращать false. По сути метод порождает функцию блокирования потока.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

$lockFunction = Predicates::lock();
CollectionFactory::numbers(1, 10)
    ->stream()
    ->filter($lockFunction)
    ->getCollection()
    ->isEmpty() // true
;
```

#### _notResistance_ - Пропуск всех значений
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
notResistance(): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая на любой набор входных данных - будет возвращать ```true```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

$passFunction = Predicates::notResistance();
CollectionFactory::numbers(1, 10)
    ->stream()
    ->filter($passFunction)
    ->getCollection()
    ->size() // 10
;
```

#### _notNull_ - проверка значений на пустоту
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
notNull(): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая на любой набор входных данных - будет возвращать ```true```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

$notNullPassFunction = Predicates::notNull();
CollectionFactory::from([1, 10, null])
    ->stream()
    ->filter($notNullPassFunction)
    ->getCollection()
    ->size() // 2
;
```

#### _eachEven_ - Пропуск элементов чётных вызовов
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
eachEven(): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая каждый четный вызов - будет возвращать ```true``` и, соответственно, в остальных случаях - ```false```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

$evenPassFunction = Predicates::eachEven();
CollectionFactory::from([1, 2, 3, 4, null, false])
    ->stream()
    ->filter($evenPassFunction)
    ->getCollection()
    ->toArray() // 2, 4, false
;
```

#### _nth_ - Пропуск элементов кратных вызовов
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
nth($number: int): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая каждый `$number` вызов - будет возвращать ```true``` и, соответственно, в остальных случаях - ```false```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

$thirdPassFunction = Predicates::nth(3);
CollectionFactory::from([1, 2, 3, 4, null, false])
    ->stream()
    ->filter($thirdPassFunction)
    ->getCollection()
    ->toArray() // 3, false
;
```

#### _equal_ - Проверка на эквивалентность
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
equal($value: mixed): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая возвращает истинное значение при совпадении элемента коллекции со значением ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, false])
    ->stream()
    ->filter(Predicates::equal(3))
    ->findFirst() // 3
;
```

#### _lockDuplicated_ - Блокировка значений дубликатов
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
lockDuplicated(): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию, которая возвращает истинное значение только для вызовов с уникальными элементами.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([3, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::lockDuplicated())
    ->getCollection()
    ->toArray() // [3, 2, 4, null]
;
```

#### _lessThan_ - Проверка значения на условие "меньше"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
lessThan($value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения элементов со значением `$value`.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::lessThan(4))
    ->getCollection()
    ->toArray() // [1, 2, 3, null, 3]
;
```

#### _lessOrEqual_ - Проверка значения на условие "меньше либо равно"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
lessOrEqual($value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения элементов со значением `$value`.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::lessOrEqual(2))
    ->getCollection()
    ->toArray() // [1, 2, null]
;
```

#### _greaterThan_ - Проверка значения на условие "больше"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
greaterThan($value: scalar): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию сравнения элементов со значением `$value`.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::greaterThan(2))
    ->getCollection()
    ->toArray() // [3, 4, 3]
;
```

#### _greaterOrEqual_ - Проверка значения на условие "больше либо равно"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
greaterOrEqual($value: scalar): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию сравнения элементов со значением `$value`.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::greaterOrEqual(2))
    ->getCollection()
    ->toArray() // [2, 3, 4, 3]
;
```

#### _not_ - Проверка значения на неравенство
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
not($value: mixed): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки неравенства элементов коллекции со значением ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::not(3))
    ->getCollection()
    ->toArray() // [1, 2, 4, null]
;
```

#### _in_ - Проверка значения на нахождение во множестве
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
in($values: array): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки нахождения элементов во множестве ```$values```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::in([null, 3]))
    ->getCollection()
    ->toArray() // [3, null, 3]
;
```

#### _notIn_ - Проверка значения на отсутствие во множестве
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
notIn($values: array): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки отсутствия элементов во множестве ```$values```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

CollectionFactory::from([1, 2, 3, 4, null, 3])
    ->stream()
    ->filter(Predicates::notIn([null, 3]))
    ->getCollection()
    ->toArray() // [1, 2, 4]
;
```

#### _where_ - Проверка свойства объекта на эквивалентность
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
where($property: string, $value: mixed): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки свойства объекта элемента на равенство значению ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::where('value', 0))
    ->getCollection()
    ->isEmpty() // false
;
```

#### _whereNot_ - Проверка свойства объекта на неравенство
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereNot($property: string, $value: mixed): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки свойства объекта элемента на неравенство значению ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereNot('value', 0))
    ->getCollection()
    ->toArray() // [#1, #2, #3, #4]
;
```

#### _whereIn_ - Проверка свойства объекта на нахождение во множестве
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereIn($property: string, $values: array): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки нахождения значения свойства объекта во множестве ```$values```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereIn('value', [0, 4, 9]))
    ->getCollection()
    ->toArray() // [#0, #4]
;
```

#### _whereNotIn_ - Проверка свойства объекта на отсутствие во множестве
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereNotIn($property: string, $values: array): Closure; \\ <Fn($el: mixed): bool>
```

Метод инициирует функцию проверки отсутствия значения свойства объекта во множестве ```$values```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereIn('value', [0, 4, 9]))
    ->getCollection()
    ->toArray() // [#0, #4]
;
```

#### _whereGreaterThan_ - Проверка свойства объекта на условие "больше"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereGreaterThan($property: string, $value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения значения свойства объекта с ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereGreaterThan('value', 3))
    ->getCollection()
    ->toArray() // [#4]
;
```

#### _whereLessThan_ - Проверка свойства объекта на условие "меньше"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereLessThan($property: string, $value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения значения свойства объекта с ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereLessThan('value', 3))
    ->getCollection()
    ->toArray() // [#0, #1, #2]
;
```

#### _whereGreaterOrEqual_ - Проверка свойства объекта на условие "больше либо равно"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereGreaterOrEqual($property: string, $value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения значения свойства объекта с ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereGreaterOrEqual('value', 3))
    ->getCollection()
    ->toArray() // [#3, #4]
;
```

#### _whereLessOrEqual_ - Проверка свойства объекта на условие "меньше либо равно"
[[↑ Predicates Предикаты]](#Predicates-предикаты)
```
whereLessOrEqual($property: string, $value: scalar): Closure; \\ <Fn($el: scalar): bool>
```

Метод инициирует функцию сравнения значения свойства объекта с ```$value```.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

$c = 0;
CollectionFactory::generate(5, static function () use (& $c) {
        return new ValueObject($c++);
    })
    ->stream()
    ->filter(Predicates::whereLessOrEqual('value', 3))
    ->getCollection()
    ->toArray() // [#1, #2, #3]
;
```

### Comparators функции сравнения
[[↑ Набор функций обхода и преобразования]](#набор-функций-обхода-и-преобразования)

Группа конструкторов функций сравнения. Функции сравнения элементов необходимы при использовании методов сортировки, для того чтобы в правильном порядке расположить элементы. Итоговые функции сортировки имеют интерфейс `<Fn($a: mixed, $b: mixed): int>`, с логикой работы идентичной [https://www.php.net/manual/ru/function.usort]. 

- [*scalarComparator* – Сравнение скалярных значений](#scalarcomparator---сравнение-скалярных-значений)
- [*objectPropertyComparator* – Сравнение свойств объектов](#objectpropertycomparator---сравнение-свойств-объектов)
- [*callbackComparator* – Определение функции для сравнения значений](#callbackcomparator---определение-функции-для-сравнения-значений)

#### _scalarComparator_ - Сравнение скалярных значений
[[↑ Comparators функции сравнения]](#Comparators-функции-сравнения)
```
scalarComparator(): Closure; \\ <Fn($a: scalar, $b: scalar): int>
```

Метод инициирует функцию, которая сравнивает два значения. Функция сравнения возвращает целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Comparators;

CollectionFactory::generate(5, static function (): int {
        return random_int(0, 10);
    })
    ->stream()
    ->sort(Comparators::scalarComparator())
    ->getCollection()
    ->toArray() // sorted value, for example [2, 3, 6, 7, 8]
;
```

#### _objectPropertyComparator_ - Сравнение свойств объектов
[[↑ Comparators функции сравнения]](#Comparators-функции-сравнения)
```
objectPropertyComparator($property: string): Closure; \\ <Fn($a: object, $b: object): int>
```

Метод инициирует функцию, которая сравнивает два значения свойства объектов. Функция сравнения возвращает целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Comparators;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

CollectionFactory::generate(5, static function () {
        return new ValueObject(random_int(0, 10));
    })    
    ->stream()
    ->sort(Comparators::objectPropertyComparator('value'))
    ->getCollection()
    ->toArray() // sorted ValueObject objects, for example [#2, #3, #6, #7, #8]
;
```

#### _callbackComparator_ - Определение функции для сравнения значений
[[↑ Comparators функции сравнения]](#Comparators-функции-сравнения)
```
callbackComparator($fun: <Fn($value: mixed): scalar>): Closure; \\ <Fn($a: mixed, $b: mixed): int>
```

Метод инициирует функцию, которая сравнивает два значения на основе их обработки функцией ``$fun``. Функция сравнения возвращает целое, которое меньше, равно или больше нуля, если первый аргумент является соответственно меньшим, равным или большим, чем второй.

```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Comparators;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

CollectionFactory::generate(5, static function () {
        return new ValueObject(random_int(0, 10));
    })    
    ->stream()
    ->sort(Comparators::callbackComparator(static function (ValueObject $valueObject) {
        return $valueObject->getValue();
    }))
    ->getCollection()
    ->toArray() // sorted ValueObject objects, for example [#2, #3, #6, #7, #8]
;

```

### Converters Преобразователи элементов
[[↑ Набор функций обхода и преобразования]](#набор-функций-обхода-и-преобразования)

Группа конструктор функций для преобразования элементов. Результатом функции конвертера является ``<Fn($obj: mixed): mixed>``.

- [*toPropertyValue* – Преобразование каждого элемента коллекции в значение свойства](#topropertyvalue---преобразование-каждого-элемента-коллекции-в-значение-свойства)
- [*toProperties* – Преобразование каждого элемента коллекции в ассоциативный массив](#toproperties---преобразование-каждого-элемента-коллекции-в-ассоциативный-массив)

#### _toPropertyValue_ - Преобразование каждого элемента коллекции в значение свойства
[[↑ Converters Преобразователи элементов]](#converters-преобразователи-элементов)
```
toPropertyValue($property: string): Closure; \\ <Fn($obj: object): mixed>
```

Метод инициирует функцию, которая возвращает значение свойства объекта.

```php

use WS\Utils\Collections\CollectionFactory;
use \WS\Utils\Collections\Functions\Converters;

class ValueObject {
    private $value;
    public function __construct($value) {
        $this->value = $value;
    }
    
    public function getValue() {
        return $this->value;
    }
}

CollectionFactory::generate(5, static function (int $index): ValueObject {
        return new ValueObject($index);
    })
    ->stream()
    ->map(Converters::toPropertyValue('value'))
    ->getCollection()
    ->toArray() // [0, 1, 2, 3, 4 ]
;

```

#### _toProperties_ - Преобразование каждого элемента коллекции в ассоциативный массив
[[↑ Converters Преобразователи элементов]](#converters-преобразователи-элементов)
```
toProperties($names: array<string>): Closure; \\ <Fn($obj: object): array>
```

Метод инициирует функцию, которая возвращает ассоциативный массив свойств объекта, ключи которого являются именами свойств.

```php

use WS\Utils\Collections\CollectionFactory;
use \WS\Utils\Collections\Functions\Converters;

class Person {
    private $name;
    private $surname;
    
    public function __construct(string $name, string $surname) 
    {
        $this->name = $name;
        $this->surname = $surname;
    }
    
    public function getName(): string 
    {
        return $this->name;
    }
    
    public function getSurname(): string
    {
        return $this->surname;
    }
}

CollectionFactory::generate(1, static function (int $index): Person {
        return new Person('Ivan', 'Ivanov');
    })
    ->stream()
    ->map(Converters::toProperties(['name', 'surname']))
    ->getCollection()
    ->toArray() // [['name' => 'Ivan', 'surname' => 'Ivanov']]
;

```

### Reorganizers Преобразователи потоков
[[↑ Набор функций обхода и преобразования]](#набор-функций-обхода-и-преобразования)

Конструкторы методов преобразования потоков. В отличие от функций преобразования элементов, где каждому элементу исходной коллекции соответствует элемент новой коллекции с учетом позиции первого, методы преобразования потоков создают производную новую коллекцию с произвольным количеством элементов.
- [*shuffle* – Смена порядка следования элементов коллекции](#shuffle---cмена-порядка-следования-элементов-коллекции)
- [*random* – Получение случайных элементов коллекции](#random---получение-случайных-элементов-коллекции)
- [*chunk* – Разбиение на множество коллекций указанного размера](#chunk---разбиение-на-множество-коллекций-указанного-размера)
- [*collapse* – Получение коллекции без дополнительных уровней вложенности](#collapse---получение-коллекции-без-дополнительных-уровней-вложенности)

#### _shuffle_ - Смена порядка следования элементов коллекции
[[↑ Reorganizers Преобразователи потоков]](#Reorganizers-преобразователи-потоков)
```
shuffle(): Closure; \\ <Fn(): Collection>
```

Метод инициирует функцию, которая возвращает новую коллекцию с измененным порядком следования элементов. Элементы будут следовать в случайном порядке.

```php

use \WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::numbers(5)
    ->stream()
    ->reorganize(Reorganizers::shuffle())
    ->getCollection()
    ->toArray() // for example [0, 3, 1, 2, 4]
;

```

#### _random_ - Получение случайных элементов коллекции
[[↑ Reorganizers Преобразователи потоков]](#Reorganizers-преобразователи-потоков)
```
random($count = 1: int): Closure; \\ <Fn(): Collection>
```

Метод инициирует функцию, функция возвращает новую коллекцию которая содержит случайное ограниченное множество элементов исходной коллекции. 

```php

use \WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::numbers(5)
    ->stream()
    ->reorganize(Reorganizers::random(2))
    ->getCollection()
    ->toArray() // for example [0, 3]
;

```

#### _chunk_ - Разбиение на множество коллекций указанного размера
[[↑ Reorganizers Преобразователи потоков]](#Reorganizers-преобразователи-потоков)
```
chunk($size: int): Closure; \\ <Fn(): Collection>
```

Метод инициирует функцию, функция возвращает коллекцию коллекций количество элементов которых меньше либо равно ``$size``. 

```php

use \WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::numbers(10)
    ->stream()
    ->reorganize(Reorganizers::chunk(2))
    ->getCollection()
    ->toArray() // for example [[0, 1], [2, 3], ...]
;

```

#### _collapse_ - Получение коллекции без дополнительных уровней вложенности
[[↑ Reorganizers Преобразователи потоков]](#Reorganizers-преобразователи-потоков)
```
collapse(): Closure; \\ <Fn(): Collection>
```

Метод инициирует функцию, функция возвращает коллекцию без вложенных контейнеров. Под контейнерами в данном контексте понимаются итерируемые структуры данных. 

```php

use \WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Reorganizers;

CollectionFactory::generate(3, static function (int $i): array {
        return [$i*2, $i*2 + 1];
    }) // [[0, 1], [2, 3], [4, 5]]
    ->stream()
    ->reorganize(Reorganizers::collapse())
    ->getCollection()
    ->toArray() // for example [0, 1, 2, 3, 4, 5]
;

```

### Consumers Потребители
[[↑ Набор функций обхода и преобразования]](#набор-функций-обхода-и-преобразования)

Конструкторы функций потребителей. Содержит одну функцию распечатки значений элементов. В основном каждая функция потребитель разрабатывается индивидуально в исходном коде проекта. 

- [*dump* – Распечатка значений элементов коллекции](#dump--–распечатка-значений-элементов-коллекции)

#### _dump_ - Распечатка значений элементов коллекции
[[↑ Consumers - Потребители]](#Consumers-потребители)
```
dump(): Closure; \\ <Fn(): Collection>
```

Метод инициирует функцию, которая распечатывает в поток вывода переданное значение.

```php

use \WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Consumers;

CollectionFactory::numbers(5)
    ->stream()
    ->each(Consumers::dump()) // dumps each element of collection
;

```
